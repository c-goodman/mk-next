import { rating, rate, Rating, ordinal } from "openskill";
import { TGamesTable, TSkillTableEntry } from "@/app/lib/definitions";

/**
 * Parameters for recording a player's skill state after a game.
 */
type RecordHistoryParams = {
  timestamp: Date;
  game_id: number;
  suid: number;
  season: number;
  player: string;
  place: number;
  character: string;
  map: string;
};

/**
 * Creates a new skill processor instance that maintains internal state
 * for calculating skill ratings (mu, sigma, ordinal) using OpenSkill,
 * based on player placements per game.
 *
 * Supports 2, 3, and 4-player free-for-all games by ignoring empty players.
 *
 * @returns {{
 *   processGame: (game: TGamesTable) => void;
 *   getHistory: () => TSkillTableEntry[];
 *   reset: () => void;
 *   getRatings: () => Record<string, Rating>;
 * }}
 */
export function createSkillProcessor() {
  // Internal state for player ratings and match history
  const currentRatings: Record<string, Rating> = {};
  const playerHistoryRows: TSkillTableEntry[] = [];

  /**
   * Retrieves the current rating for a player, or initializes it.
   */
  function getOrInitPlayerRating(player: string): Rating {
    if (!currentRatings[player]) {
      currentRatings[player] = rating();
    }
    return currentRatings[player];
  }

  /**
   * Stores the current skill snapshot for a player after a game.
   */
  function recordHistory({
    timestamp,
    game_id,
    suid,
    season,
    player,
    place,
    character,
    map,
  }: RecordHistoryParams) {
    const r = currentRatings[player];
    playerHistoryRows.push({
      timestamp,
      game_id,
      suid,
      season,
      player,
      place,
      character,
      map,
      mu: r.mu,
      sigma: r.sigma,
      ordinal: ordinal(r),
    });
  }

  /**
   * Processes a single game by updating player ratings and storing history.
   * Skips null/empty players automatically.
   *
   * @param game The game data to process.
   */
  function processGame(game: TGamesTable) {
    // Extract player names and characters, trimming empty entries
    const playerNames = [
      game.players_1st,
      game.players_2nd,
      game.players_3rd,
      game.players_4th,
    ].filter((name) => name && name.trim() !== "");

    const playerCharacters = [
      game.characters_1st,
      game.characters_2nd,
      game.characters_3rd,
      game.characters_4th,
    ].filter((char) => char && char.trim() !== "");

    // Create ranks [1, 2, 3, ...]
    const ranks = Array.from({ length: playerNames.length }, (_, i) => i + 1);

    // Wrap each player in its own team array (Free For All)
    const ratedTeams = playerNames.map((name) => [getOrInitPlayerRating(name)]);

    // Calculate new ratings using OpenSkill
    const newRatings = rate(ratedTeams, { rank: ranks });

    // Update player ratings and store the history
    playerNames.forEach((player, i) => {
      currentRatings[player] = newRatings[i][0];
      recordHistory({
        timestamp: game.timestamp,
        game_id: game.id,
        suid: game.suid,
        season: game.season,
        player,
        place: ranks[i],
        character: playerCharacters[i],
        map: game.map,
      });
    });
  }

  function resetRatings() {
    for (const key in currentRatings) {
      delete currentRatings[key];
    }
  }

  return {
    /**
     * Process a single game (2–4 players), updating internal ratings/history.
     */
    processGame: processGame,

    /**
     * Get the current skill ratings for all players.
     */
    getCurrentRatings: () => currentRatings,

    /**
     * Get the full player history generated by this processor.
     */
    getHistory: () => playerHistoryRows,

    /**
     * Reset the internal rating and history state — useful between seasons.
     */
    resetRatings: resetRatings,
  };
}
