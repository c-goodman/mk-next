import { db } from "@vercel/postgres";
import { ordinal, rate, Rating, rating } from "openskill";
import "dotenv/config";
import {
  TGamesTable,
  TLatestSkillTable,
  TSkillTableEntry,
} from "@/app/lib/definitions";

import { fetchLatestSkillPerSeasonFourPlayer } from "@/app/lib/data";

// Convert latest ratings to Record<playerName, latestRating> type
export function handleBuildSkillRating(
  latestSkill: TLatestSkillTable[]
): Record<string, Rating> {
  const ratings: Record<string, Rating> = {};

  // For each Latest Skill Table Record
  // Records should be unique to player
  for (const row of latestSkill) {
    // Populate a Record where the key is player
    // And the value is an openskill Rating built from most recent mu and sigma values
    ratings[row.player] = rating({ mu: row.mu, sigma: row.sigma });
  }

  return ratings;
}

// Handle initial data loading
export async function handleLatestSkill() {
  // Get latest ratings from DB
  const latestRatingsInitial = await fetchLatestSkillPerSeasonFourPlayer();

  // If data fetch returns empty or undefined continue
  if (!latestRatingsInitial) {
    return;
  }

  // Otherwise convert latest ratings to Record<playerName, latestRating> type
  const latestRatings = handleBuildSkillRating(latestRatingsInitial);

  return latestRatings;
}

interface IUpdateSkillRatings {
  latestRatings: Record<string, Rating>;
}

export function updateRatings({ latestRatings }: IUpdateSkillRatings) {
  // Internal state for player ratings and match history
  const currentRatings: Record<string, Rating> = {};
  const newRatingRows: TSkillTableEntry[] = [];

  function processUpdate(game: TGamesTable) {
    // Extract player names and characters
    // Trimming empty entries so function works for all game types 2, 3, 4 player
    const playerNames = [
      game.players_1st,
      game.players_2nd,
      game.players_3rd,
      game.players_4th,
    ].filter((name) => name && name.trim() !== "");

    const playerCharacters = [
      game.characters_1st,
      game.characters_2nd,
      game.characters_3rd,
      game.characters_4th,
    ].filter((char) => char && char.trim() !== "");

    // Create ranks array [1, 2, 3, ...]
    // Based on the length of the trimmed array (works for all game types)
    const ranks = Array.from({ length: playerNames.length }, (_, i) => i + 1);

    // If any player in the current game does not have a matching key in the..
    // ..most recent ratings, reset their rating
    // Wrap each player in its own team array (Free For All)
    const latestOrInitRatings = playerNames.map((player) =>
      latestRatings[player] ? [latestRatings[player]] : [rating()]
    );

    // Update new ratings based on old ratings and player associated ranks
    const newRatings = rate(latestOrInitRatings, { rank: ranks });

    // Update player ratings and store the history
    playerNames.forEach((player, i) => {
      const r = newRatings[i][0];
      recordNewData({
        timestamp: game.timestamp,
        game_id: game.id,
        suid: game.suid,
        season: game.season,
        player,
        place: ranks[i], // Associated place in the game
        character: playerCharacters[i], // Associated character
        map: game.map,
        mu: r.mu,
        sigma: r.sigma,
        ordinal: ordinal(r),
      });
    });
  }

  // Push new values to new record, including newly calculated rating data
  function recordNewData({
    timestamp,
    game_id,
    suid,
    season,
    player,
    place,
    character,
    map,
    mu,
    sigma,
    ordinal,
  }: TSkillTableEntry) {
    newRatingRows.push({
      timestamp,
      game_id,
      suid,
      season,
      player,
      place,
      character,
      map,
      mu,
      sigma,
      ordinal,
    });
  }

  // TODO: Test this
  // Reset for new season rollover
  function resetRatings() {
    for (const key in currentRatings) {
      delete currentRatings[key];
    }
  }

  return {
    /**
     * Process a single game (2–4 players), updating internal ratings/history.
     */
    processUpdate: processUpdate,

    /**
     * Get the current skill ratings for all players.
     */
    getCurrentRatings: () => currentRatings,

    /**
     * Get the full player history generated by this processor.
     */
    getNewData: () => newRatingRows,

    /**
     * Reset the internal rating and history state — useful between seasons.
     */
    resetRatings: resetRatings,
  };
}

// Wrapper for all logic
export async function handleExistingOrInitialSkill(
  newGames: TGamesTable[] | TGamesTable
) {
  // Convert single to array
  // Want to accept an array of games or a single game
  // Updates for everyone!
  const games = Array.isArray(newGames) ? newGames : [newGames];

  // Query db for latest Skill data
  // TODO: Choice on target table here?
  const latestSkill = await handleLatestSkill();

  // Handle undefined promise, pass to next sad boi
  if (!latestSkill) {
    return;
  }

  // TODO: Need history games??
  const updateFactory = updateRatings({ latestRatings: latestSkill });

  // For each game update with regard to the latest data
  // TODO: TODO: TODO: TEST THIS YOU FUCKING IDIOT
  // This could fail if the currently tracked player state gets referenced outside the factory somehow...
  for (const g of games) {
    updateFactory.processUpdate(g);
  }

  // Return the updated records
  const updateRows = updateFactory.getNewData();

  return updateRows;
}

async function main() {
  const client = await db.connect();
  try {
    //   if (if_exists === "replace") {
    //     await client.sql`
    //   DROP TABLE IF EXISTS mk_skill_all_time_four_player;
    // `;
    //   }

    await client.sql`
      CREATE TABLE IF NOT EXISTS mk_skill_all_time_four_player (
        id SERIAL PRIMARY KEY
        ,TIMESTAMP TIMESTAMP WITH TIME ZONE NOT NULL
        ,GAME_ID SERIAL NOT NULL
        ,SUID SERIAL NOT NULL
        ,SEASON SMALLINT NOT NULL
        ,PLAYER VARCHAR(255) NOT NULL
        ,PLACE SMALLINT NOT NULL
        ,CHARACTER VARCHAR(255) NOT NULL
        ,MAP VARCHAR(255) NOT NULL
        ,MU DOUBLE PRECISION NOT NULL
        ,SIGMA DOUBLE PRECISION NOT NULL
        ,ORDINAL DOUBLE PRECISION NOT NULL
      );
    `;

    await client.sql`
  CREATE INDEX IF NOT EXISTS idx_skill_all_time_game_id 
    ON mk_skill_all_time_four_player(game_id);
  `;

    const games = await client.sql<TGamesTable>`
      SELECT 
        mk_form_data.id
        ,mk_form_data.timestamp
        ,mk_form_data.new_session
        ,mk_form_data.suid
        ,mk_form_data.map
        ,mk_form_data.players
        ,mk_form_data.players_1st
        ,mk_form_data.players_2nd
        ,mk_form_data.players_3rd
        ,mk_form_data.players_4th
        ,mk_form_data.characters_1st
        ,mk_form_data.characters_2nd
        ,mk_form_data.characters_3rd
        ,mk_form_data.characters_4th
        ,mk_form_data.season
        ,mk_form_data.suid_window_start
        ,mk_form_data.suid_window_end
      FROM mk_form_data
        WHERE mk_form_data.players = '4'
        AND mk_form_data.id NOT IN (
          SELECT DISTINCT game_id FROM mk_skill_all_time_four_player
        )
    `;

    if (games.rows.length === 0 || !games) {
      console.log("No new games to process. Skipping.");
      return;
    }

    const testVal = await handleExistingOrInitialSkill(games.rows[0]);

    console.log(testVal);
  } finally {
    await client.release();
  }
}

main().catch(console.error);
