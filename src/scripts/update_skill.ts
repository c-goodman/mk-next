import { db } from "@vercel/postgres";
import { fetchLatestSkillPerSeasonFourPlayer } from "@/app/lib/data";
import { ordinal, rate, Rating, rating } from "openskill";
import "dotenv/config";
import {
  TGamesTable,
  TLatestSkillTable,
  TSkillTableEntry,
} from "@/app/lib/definitions";

// Convert latest ratings to Record<playerName, latestRating> type
export function handleBuildSkillRating(
  latestSkill: TLatestSkillTable[]
): Record<string, Rating> {
  const ratings: Record<string, Rating> = {};

  // For each Latest Skill Table Record
  // Records should be unique to player
  for (const row of latestSkill) {
    // Populate a Record where the key is player
    // And the value is an openskill Rating built from most recent mu and sigma values
    ratings[row.player] = rating({ mu: row.mu, sigma: row.sigma });
  }

  return ratings;
}

// Handle initial data loading
export async function handleLatestSkill() {
  // Get latest ratings from DB
  const latestRatingsInitial = await fetchLatestSkillPerSeasonFourPlayer();

  // If data fetch returns empty or undefined continue
  if (!latestRatingsInitial) {
    return;
  }

  // Otherwise convert latest ratings to Record<playerName, latestRating> type
  const latestRatings = handleBuildSkillRating(latestRatingsInitial);

  return latestRatings;
}

interface IUpdateSkillRatings {
  latestRatings: Record<string, Rating>;
}

export function updateRatings({ latestRatings }: IUpdateSkillRatings) {
  // Internal state for player ratings and match history
  const currentRatings: Record<string, Rating> = {};
  const newRatingRows: TSkillTableEntry[] = [];

  function processUpdate(game: TGamesTable) {
    // Extract player names and characters
    // Trimming empty entries so function works for all game types 2, 3, 4 player
    const playerNames = [
      game.players_1st,
      game.players_2nd,
      game.players_3rd,
      game.players_4th,
    ].filter((name) => name && name.trim() !== "");

    const playerCharacters = [
      game.characters_1st,
      game.characters_2nd,
      game.characters_3rd,
      game.characters_4th,
    ].filter((char) => char && char.trim() !== "");

    // Create ranks array [1, 2, 3, ...]
    // Based on the length of the trimmed array (works for all game types)
    const ranks = Array.from({ length: playerNames.length }, (_, i) => i + 1);

    // If any player in the current game does not have a matching key in the..
    // ..most recent ratings, reset their rating
    // Wrap each player in its own team array (Free For All)
    const latestOrInitRatings = playerNames.map((player) =>
      latestRatings[player] ? [latestRatings[player]] : [rating()]
    );

    // Update new ratings based on old ratings and player associated ranks
    const newRatings = rate(latestOrInitRatings, { rank: ranks });

    // Update player ratings and store the history
    playerNames.forEach((player, i) => {
      const r = newRatings[i][0];
      recordNewData({
        timestamp: game.timestamp,
        game_id: game.id,
        suid: game.suid,
        season: game.season,
        player,
        place: ranks[i], // Associated place in the game
        character: playerCharacters[i], // Associated character
        map: game.map,
        mu: r.mu,
        sigma: r.sigma,
        ordinal: ordinal(r),
      });
    });
  }

  // Push new values to new record, including newly calculated rating data
  function recordNewData({
    timestamp,
    game_id,
    suid,
    season,
    player,
    place,
    character,
    map,
    mu,
    sigma,
    ordinal,
  }: TSkillTableEntry) {
    newRatingRows.push({
      timestamp,
      game_id,
      suid,
      season,
      player,
      place,
      character,
      map,
      mu,
      sigma,
      ordinal,
    });
  }

  // TODO: Test this
  // Reset for new season rollover
  function resetRatings() {
    for (const key in currentRatings) {
      delete currentRatings[key];
    }
  }

  return {
    /**
     * Process a single game (2–4 players), updating internal ratings/history.
     */
    processUpdate: processUpdate,

    /**
     * Get the current skill ratings for all players.
     */
    getCurrentRatings: () => currentRatings,

    /**
     * Get the full player history generated by this processor.
     */
    getNewData: () => newRatingRows,

    /**
     * Reset the internal rating and history state — useful between seasons.
     */
    resetRatings: resetRatings,
  };
}

// Wrapper for all logic
async function handleExistingOrInitialSkill(
  newGames: TGamesTable[] | TGamesTable
) {
  // Convert single to array
  // Want to accept an array of games or a single game
  // Updates for everyone!
  const games = Array.isArray(newGames) ? newGames : [newGames];

  // Query db for latest Skill data
  // TODO: Choice on target table here?
  const latestSkill = await handleLatestSkill();

  // Handle undefined promise, pass to next sad boi
  if (!latestSkill) {
    return;
  }

  // TODO: Need history games??
  const updateFactory = updateRatings({ latestRatings: latestSkill });

  // For each game update with regard to the latest data
  // TODO: TODO: TODO: TEST THIS YOU FUCKING IDIOT
  // This could fail if the currently tracked player state gets referenced outside the factory somehow...
  for (const g of games) {
    updateFactory.processUpdate(g);
  }

  // Return the updated records
  const updateRows = updateFactory.getNewData();

  return updateRows;
}

async function main() {
  const client = await db.connect();
  try {
    const newGame: TGamesTable[] = [
      {
        id: 1,
        timestamp: new Date("2024-06-21 12:00:00+00"),
        new_session: "YES",
        suid: 1,
        map: "Wario Stadium",
        players: 4,
        players_1st: "Blake",
        players_2nd: "Cooper",
        players_3rd: "Matt",
        players_4th: "Garrett",
        characters_1st: "Toad",
        characters_2nd: "Bowser",
        characters_3rd: "Yoshi",
        characters_4th: "Peach",
        season: 11,
        suid_window_start: new Date("2024-06-21 07:00:00+00"),
        suid_window_end: new Date("2024-06-22 07:00:00+00"),
        image_url: "",
      },
      {
        id: 2,
        timestamp: new Date("2024-06-21 12:00:00+00"),
        new_session: "YES",
        suid: 1,
        map: "Wario Stadium",
        players: 4,
        players_1st: "Garrett",
        players_2nd: "Blake",
        players_3rd: "RickyBob",
        players_4th: "Matt",
        characters_1st: "Toad",
        characters_2nd: "Bowser",
        characters_3rd: "Yoshi",
        characters_4th: "Peach",
        season: 11,
        suid_window_start: new Date("2024-06-21 07:00:00+00"),
        suid_window_end: new Date("2024-06-22 07:00:00+00"),
        image_url: "",
      },
    ];

    const testVal = await handleExistingOrInitialSkill(newGame);

    console.log(testVal);
  } finally {
    await client.release();
  }
}

main().catch(console.error);
